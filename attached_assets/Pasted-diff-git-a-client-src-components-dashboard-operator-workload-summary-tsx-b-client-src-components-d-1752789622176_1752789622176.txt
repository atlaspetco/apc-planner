diff --git a/client/src/components/dashboard/operator-workload-summary.tsx b/client/src/components/dashboard/operator-workload-summary.tsx
index 131d932ebf5955381bdbfa686abd5b3676e69fb0..75b114b3f5333ccb11d3ec309cf00368f4a7331f 100644
--- a/client/src/components/dashboard/operator-workload-summary.tsx
+++ b/client/src/components/dashboard/operator-workload-summary.tsx
@@ -23,117 +23,123 @@ export function OperatorWorkloadSummary({ assignments }: OperatorWorkloadSummary
   const [selectedOperator, setSelectedOperator] = useState<any | null>(null);
   const [isModalOpen, setIsModalOpen] = useState(false);
   // Fetch operator data for workload calculations
   const { data: operatorsData, error: operatorsError } = useQuery({
     queryKey: ["/api/operators"],
     staleTime: 5 * 60 * 1000, // 5 minutes
   });
 
   // Fetch UPH data for more accurate time calculations
   const { data: uphData } = useQuery({
     queryKey: ["/api/uph-analytics/table-data"],
     staleTime: 5 * 60 * 1000, // 5 minutes
   });
 
   // Calculate workload summary from assignments
   const workloadSummary = React.useMemo(() => {
     // Handle both direct array and wrapped operators response
     const operators = operatorsData?.operators || operatorsData || [];
     if (!assignments || !operators.length) return [];
 
     const operatorMap = new Map();
     operators.forEach(op => {
       operatorMap.set(op.id, {
         operatorId: op.id,
         operatorName: op.name,
-        totalAssignments: 0,
         totalEstimatedHours: 0,
         availableHours: op.availableHours || 40, // Default 40h/week
         observations: op.observations || 0,
-        assignments: []
+        assignments: [],
+        moIds: new Set<number>()
       });
     });
 
     // Process assignments to calculate workload using UPH data
     Array.from(assignments.values()).forEach(assignment => {
       const operator = operatorMap.get(assignment.operatorId);
       if (operator) {
-        operator.totalAssignments++;
+        // Track unique MOs this operator is assigned to
+        if (assignment.productionOrderId) {
+          operator.moIds.add(assignment.productionOrderId);
+        }
         // Store complete assignment data for the modal
         operator.assignments.push({
           ...assignment,
           // Ensure all required fields are present
           productRouting: assignment.productRouting || assignment.routing || 'Unknown',
           workCenter: assignment.workCenter || 'Unknown',
           quantity: assignment.quantity || 0,
           productionOrderId: assignment.productionOrderId || null
         });
         
         // Calculate estimated hours based on UPH data if available
         let estimatedHours = 1; // Default fallback
         if (uphData?.uphResults && assignment.quantity > 0) {
           const uphEntry = uphData.uphResults.find(entry => 
             entry.operatorName === assignment.operatorName &&
             entry.workCenter === assignment.workCenter &&
             entry.productRouting === (assignment.productRouting || assignment.routing)
           );
           
           if (uphEntry && uphEntry.unitsPerHour > 0) {
             estimatedHours = assignment.quantity / uphEntry.unitsPerHour;
           }
         }
         
         operator.totalEstimatedHours += estimatedHours;
       }
     });
 
     // Convert to array and add calculated fields
     return Array.from(operatorMap.values()).map(operator => {
+      // Calculate total assignments based on unique MO IDs
+      const totalAssignments = operator.moIds.size;
       const capacityPercent = Math.round((operator.totalEstimatedHours / operator.availableHours) * 100);
       
       // Calculate total observations from UPH data
       let totalObservations = 0;
       if (uphData?.uphResults) {
         const operatorUphEntries = uphData.uphResults.filter(entry => 
           entry.operatorName === operator.operatorName
         );
         totalObservations = operatorUphEntries.reduce((sum, entry) => sum + (entry.observations || 0), 0);
       }
       
       // Estimate completion date based on workload
       const daysToComplete = Math.ceil(operator.totalEstimatedHours / 8); // 8 hours per day
       const completionDate = new Date();
       completionDate.setDate(completionDate.getDate() + daysToComplete);
       
       return {
         ...operator,
         observations: totalObservations,
         capacityPercent,
-        estimatedCompletion: completionDate.toLocaleDateString('en-US', { 
-          weekday: 'short', 
-          month: 'short', 
-          day: 'numeric' 
+        totalAssignments,
+        estimatedCompletion: completionDate.toLocaleDateString('en-US', {
+          weekday: 'short',
+          month: 'short',
+          day: 'numeric'
         })
       };
     }).filter(operator => operator.totalAssignments > 0) // Only show operators with assignments
      .sort((a, b) => b.totalAssignments - a.totalAssignments); // Sort by workload
   }, [assignments, operatorsData, uphData]);
 
 
 
   if (!workloadSummary.length) {
     return (
       <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
         <div className="flex items-center space-x-2 mb-4">
           <Users className="text-blue-600 w-5 h-5" />
           <h2 className="text-lg font-semibold text-gray-900">Operator Workload Summary</h2>
         </div>
         <div className="text-gray-500 text-center py-4">
           No operator assignments found. Assign operators to work orders to see workload summary.
         </div>
       </div>
     );
   }
 
   // Calculate summary stats
   const totalAssignments = workloadSummary.reduce((sum, op) => sum + op.totalAssignments, 0);
   const totalHours = workloadSummary.reduce((sum, op) => sum + op.totalEstimatedHours, 0);
