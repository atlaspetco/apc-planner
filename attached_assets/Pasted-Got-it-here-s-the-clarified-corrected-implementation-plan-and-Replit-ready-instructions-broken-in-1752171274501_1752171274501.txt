Got it ‚Äî here‚Äôs the clarified, corrected implementation plan and Replit-ready instructions broken into precise steps:

‚∏ª

‚úÖ Objective

Fix the app‚Äôs ability to:
	1.	Fetch Work Orders, but only for Active MOs on the Planning Dashboard
	2.	Accurately track real quantities by:
	‚Ä¢	Aggregating duration from cycles (by operator + work center + MO)
	‚Ä¢	Storing that with production_id, operator, and timestamp
	‚Ä¢	Later linking to quantity from Fulfil‚Äôs /production.order where state=done
	3.	Pull minimal data for performance: production.id, quantity, work_orders only.

‚∏ª

üß± Fix Instructions for Replit

üì• Step 1: Add Fetch for Work Orders (only for Active MOs)

// server/fulfil-api.ts
export async function fetchWorkOrdersForActiveMOs(activeMoIds: number[]) {
  const response = await axios.post(
    `${BASE_URL}/model/work.order/search_read`,
    {
      domain: [["production_id", "in", activeMoIds]],
      fields: ["id", "name", "production_id", "work_center_id", "operator_id", "state", "duration", "qty_produced"],
      limit: 1000,
    },
    {
      headers: {
        Authorization: `Bearer ${TOKEN}`,
        "Content-Type": "application/json",
      },
    }
  );
  return response.data;
}

Used only for MOs in state = "confirmed", filtered from dashboard context.

‚∏ª

üì¶ Step 2: Fetch Real Quantities for done MOs Only

// server/fulfil-api.ts
export async function fetchDoneMOQuantities() {
  const response = await axios.post(
    `${BASE_URL}/model/production.order/search_read`,
    {
      domain: [["state", "=", "done"]],
      fields: ["id", "quantity", "work_order_ids"],
      limit: 1000,
    },
    {
      headers: {
        Authorization: `Bearer ${TOKEN}`,
        "Content-Type": "application/json",
      },
    }
  );

  // Only return minimal info needed
  return response.data.map((mo: any) => ({
    id: mo.id,
    quantity: mo.quantity,
    workOrderIds: mo.work_order_ids,
  }));
}

‚ö†Ô∏è Use this to refresh UPH rows with quantity per production_id.

‚∏ª

üìä Step 3: Store Work Cycle Durations Per MO

Update or ensure your aggregation function stores duration totals per unique triplet:

{
  production_id: 12345,
  operator_name: "Jane Doe",
  work_center: "Assembly",
  total_duration_seconds: 7260,
  write_date: new Date("2025-07-10T12:00:00Z"),
}

‚Üí Insert into uphData (or equivalent), using production_id as foreign key.

‚∏ª

üîÑ Step 4: Link Quantity via Local DB (refreshed daily or via button)

Set up a cron or button-triggered refresh:

// Refresh done MO quantities and update existing UPH rows
export async function updateDoneQuantitiesInUPH() {
  const doneMOs = await fetchDoneMOQuantities();

  for (const mo of doneMOs) {
    await db.update(uphData)
      .set({ totalQuantity: mo.quantity })
      .where(eq(uphData.productionId, mo.id));
  }

  console.log(`Updated quantities for ${doneMOs.length} done MOs`);
}

Can also trigger from dashboard UI button via POST /api/uph/update-quantities.

‚∏ª

üß™ Debugging Suggestions
	‚Ä¢	Add this log after importing durations:

console.log(`Saved duration for operator=${operator} / production_id=${productionId}: ${duration}s`);

	‚Ä¢	After quantity update:

console.log(`MO ${mo.id}: quantity=${mo.quantity}, linked to ${uphRows.length} UPH rows`);


‚∏ª

‚úÖ Summary Table

Feature	Status	Fix Implemented
Fetch WOs for active MOs	‚úÖ New	fetchWorkOrdersForActiveMOs()
Store duration by MO/operator	‚úÖ Existing	Confirmed by parsing loop
Pull quantities only from done	‚úÖ New	fetchDoneMOQuantities()
Join data via production.id	‚úÖ Manual	DB-level update() using ID match
Dashboard logic (aggregation)	‚ö†Ô∏è In place	Adjust to conditionally show by WO


‚∏ª

Let me know if you want:
	‚Ä¢	SQL schema edits to support faster production_id ‚Üí UPH linking
	‚Ä¢	UI changes to support per-WO drilldowns in dashboard
	‚Ä¢	Logs for missing data edge cases (e.g. quantity still 0 after done)